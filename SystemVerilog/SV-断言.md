# SV-断言
## 1、断言的作用
简单而言断言就是检查某一行为与我们的预期是否相符，如果相符则断言成功否则断言失败。举个例子，这个行为可以是：

1)A信号有效后(由当拍算起)三拍内B信号值跳变为5

2)vld信号有效时data信号不能为X态

那么针对这两个行为我们都可以写出断言，一旦仿真中行为不符合了那么会报错。

断言可以放在过程块(procedural block)、模块(module)、接口(interface)和程序(program)中。

## 2、断言的时间点
断言要熟记两个时间点：采样时刻和匹配时刻，断言是在preponed域采样，在observed域执行检查。简单来说断言的采样点处于时钟上升沿之前、module中@clk采样时刻之后，也就是说采样到的是上升沿之前的旧值。验证环境中，@clk进行采样时的采样顺序可以简记为module @clk采样(旧值)->断言采样(旧值)->program @clk采样(新值，跳变后的)。

## 3、信号与序列
信号(signal)和序列(sequence)是断言中最常用的两个概念，这里单一介绍序列。序列可以是"简单的同一个时钟边沿被求值的布尔表达式，或者是连续多个时钟周期求值的事件"。简单来说，a==1是一个序列，a有效的三拍内b也有效且b有效的当拍c==5也是一个序列。

## 4、运算符
- a ## 3b:延时运算符

含义是a有效后的第3拍(a有效当拍为第0拍)，b也有效。如果b在第3拍未能有效，则序列匹配失败。例如如下波形图，信号a在第60ns采样判定为1，开始进行序列的匹配；在第120ns即开始匹配后的第3拍，采样信号b的值为1，则判定开始与60ns的序列匹配成功。

![延时运算符波形1](./image/%E5%BB%B6%E6%97%B6%E8%BF%90%E7%AE%97%E7%AC%A61.png "延时运算符波形1")

再看下一个波形，注意我们使用的值都是时钟沿之前的信号值，匹配点可以认为在时钟沿之后一点点。那么对于下面的波形，(起始于)160ns的序列匹配成功，180ns的序列匹配成功，200ns的序列匹配失败因为在260ns处信号b不为1。

![延时运算符波形2](./image/%E5%BB%B6%E6%97%B6%E8%BF%90%E7%AE%97%E7%AC%A62.png "延时运算符波形2")

> 拓展：延时运算符的全集是 a ##[m:n]b，例如写成a ##[2:4]b意味着a有效后的第2拍到第4拍之间b有效至少一次则序列匹配成功。

> ##0这个信号用于两个序列紧密连接，a ##0 b即a事件的结束与b事件的开始发生在同一拍。

- a[*3]:连续重复运算符

含义是a连续为1重复3拍，即a##1 a##1 a，参见下面的波形，160ns处起始的序列在200ns处匹配成功一次。

![连续重复运算符波形1](./image/%E8%BF%9E%E7%BB%AD%E9%87%8D%E5%A4%8D%E8%BF%90%E7%AE%97%E7%AC%A61.png "连续重复运算符波形1")

接下来理解一下(a##1 b)[*3]，这个序列等同于(a##1b)##1(a##1b)##1(a##1b)，对于下面的波形会在80ns处开始尝试匹配，在160ns处匹配成功。

![连续重复运算符波形2](./image/%E8%BF%9E%E7%BB%AD%E9%87%8D%E5%A4%8D%E8%BF%90%E7%AE%97%E7%AC%A62.png "连续重复运算符波形2")

> 拓展：连续重复运算符的全集是a[*m:n]b，如a[*2:4]b含义为a信号重复2~4拍后b信号有效均可匹配成功，等同于a[*2]b or a[*3]b or a[*4]b。
> 注： 延时运算符和连续重复运算符中(a、b、c)既允许使用表达式，又允许使用序列；而接下来要看的跟随重复和非连续重复则只能使用表达式， 不能使用序列。

- a[->3]:非连续跟随重复符

含义是a非连续重复3次，只在第3次重复时刻点匹配(跟随含义)，不妨直接看这个序列a##1b[->3]##1c，这个序列表示在a有效之后，c有效之前，b应该有效3次且最后一次有效的时间应当恰好比c有效早1拍(跟随性)；

![非连续跟随重复符波形1](./image/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E8%B7%9F%E9%9A%8F%E9%87%8D%E5%A4%8D%E7%AC%A61.png "非连续跟随重复符波形1")

在60ns处a信号有效，在160ns处b[->3]有效，下一拍c信号有效，整个序列在180ns处匹配成功，注意b信号有效是不需要跟随a信号的，也就是说下面这个波形也是可以匹配成功的。

![非连续跟随重复符波形2](./image/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E8%B7%9F%E9%9A%8F%E9%87%8D%E5%A4%8D%E7%AC%A62.png "非连续跟随重复符波形2")

> 拓展：非连续跟随重复符的全集是a[->m:n]b，那么就是a重复m次或者n次时均匹配成功，对于a##1b[->2:3]##1c这个序列，以下两个波形都是在180ns处匹配成功。

![非连续跟随重复符波形3](./image/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E8%B7%9F%E9%9A%8F%E9%87%8D%E5%A4%8D%E7%AC%A63.png "非连续跟随重复符波形3")

- a[=3]:非连续(无所谓跟随)重复操作符

含义是a无所谓连续不连续，反正重复3次那么就成功了。a[=1]等价于(!a)[*0:$]##1 a##1 (!a)[*0:$]，分析：(!a)的意思是a事件没有发生，(!a)[*0:$]意思是a任意多拍都没有发生($代表大于等于前面的那个值的任意数)，结合起来的意思就是a任意多拍都没有发生，终于在某一拍有效，有效之后，后面任意多拍都无效。

简单看一下a[=3]的波形理解

![非连续重复操作符1](./image/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%E7%AC%A61.png "非连续重复操作符1")

在图中标蓝的点都是匹配成功的点

- and运算符
  
and运算符用来连接两个事件(多为序列)，当两个事件均成功时匹配成功，需要注意的是两个事件必须有相同的起始点，但是可以有不同的结束点。举个简单的例子，(a##[2:4]b)and(a##5 c)在波形中可见，100ns处(a##[2:4]b)匹配成功，140ns处整个序列匹配成功，其他时间都是匹配失败的

