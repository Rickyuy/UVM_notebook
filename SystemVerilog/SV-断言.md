# SV-断言
## 1、断言的作用
简单而言断言就是检查某一行为与我们的预期是否相符，如果相符则断言成功否则断言失败。举个例子，这个行为可以是：

1)A信号有效后(由当拍算起)三拍内B信号值跳变为5

2)vld信号有效时data信号不能为X态

那么针对这两个行为我们都可以写出断言，一旦仿真中行为不符合了那么会报错。

断言可以放在过程块(procedural block)、模块(module)、接口(interface)和程序(program)中。

## 2、断言的时间点
断言要熟记两个时间点：采样时刻和匹配时刻，断言是在preponed域采样，在observed域执行检查。简单来说断言的采样点处于时钟上升沿之前、module中@clk采样时刻之后，也就是说采样到的是上升沿之前的旧值。验证环境中，@clk进行采样时的采样顺序可以简记为module @clk采样(旧值)->断言采样(旧值)->program @clk采样(新值，跳变后的)。

## 3、信号与序列
信号(signal)和序列(sequence)是断言中最常用的两个概念，这里单一介绍序列。序列可以是"简单的同一个时钟边沿被求值的布尔表达式，或者是连续多个时钟周期求值的事件"。简单来说，a==1是一个序列，a有效的三拍内b也有效且b有效的当拍c==5也是一个序列。

## 4、运算符
- a ## 3b:延时运算符

含义是a有效后的第3拍(a有效当拍为第0拍)，b也有效。如果b在第3拍未能有效，则序列匹配失败。例如如下波形图，信号a在第60ns采样判定为1，开始进行序列的匹配；在第120ns即开始匹配后的第3拍，采样信号b的值为1，则判定开始与60ns的序列匹配成功。

![延时运算符波形1](./image/%E5%BB%B6%E6%97%B6%E8%BF%90%E7%AE%97%E7%AC%A61.png "延时运算符波形1")

再看下一个波形，注意我们使用的值都是时钟沿之前的信号值，匹配点可以认为在时钟沿之后一点点。那么对于下面的波形，(起始于)160ns的序列匹配成功，180ns的序列匹配成功，200ns的序列匹配失败因为在260ns处信号b不为1。

![延时运算符波形2](./image/%E5%BB%B6%E6%97%B6%E8%BF%90%E7%AE%97%E7%AC%A62.png "延时运算符波形2")

> 拓展：延时运算符的全集是 a ##[m:n]b，例如写成a ##[2:4]b意味着a有效后的第2拍到第4拍之间b有效至少一次则序列匹配成功。

> ##0这个信号用于两个序列紧密连接，a ##0 b即a事件的结束与b事件的开始发生在同一拍。

- a[*3]:连续重复运算符

含义是a连续为1重复3拍，即a##1 a##1 a，参见下面的波形，160ns处起始的序列在200ns处匹配成功一次。

![连续重复运算符波形1](./image/%E8%BF%9E%E7%BB%AD%E9%87%8D%E5%A4%8D%E8%BF%90%E7%AE%97%E7%AC%A61.png "连续重复运算符波形1")

接下来理解一下(a##1 b)[*3]，这个序列等同于(a##1b)##1(a##1b)##1(a##1b)，对于下面的波形会在80ns处开始尝试匹配，在160ns处匹配成功。

![连续重复运算符波形2](./image/%E8%BF%9E%E7%BB%AD%E9%87%8D%E5%A4%8D%E8%BF%90%E7%AE%97%E7%AC%A62.png "连续重复运算符波形2")

> 拓展：连续重复运算符的全集是a[*m:n]b，如a[*2:4]b含义为a信号重复2~4拍后b信号有效均可匹配成功，等同于a[*2]b or a[*3]b or a[*4]b。
> 注： 延时运算符和连续重复运算符中(a、b、c)既允许使用表达式，又允许使用序列；而接下来要看的跟随重复和非连续重复则只能使用表达式， 不能使用序列。

- a[->3]:非连续跟随重复符

含义是a非连续重复3次，只在第3次重复时刻点匹配(跟随含义)，不妨直接看这个序列a##1b[->3]##1c，这个序列表示在a有效之后，c有效之前，b应该有效3次且最后一次有效的时间应当恰好比c有效早1拍(跟随性)；

![非连续跟随重复符波形1](./image/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E8%B7%9F%E9%9A%8F%E9%87%8D%E5%A4%8D%E7%AC%A61.png "非连续跟随重复符波形1")

在60ns处a信号有效，在160ns处b[->3]有效，下一拍c信号有效，整个序列在180ns处匹配成功，注意b信号有效是不需要跟随a信号的，也就是说下面这个波形也是可以匹配成功的。

![非连续跟随重复符波形2](./image/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E8%B7%9F%E9%9A%8F%E9%87%8D%E5%A4%8D%E7%AC%A62.png "非连续跟随重复符波形2")

> 拓展：非连续跟随重复符的全集是a[->m:n]b，那么就是a重复m次或者n次时均匹配成功，对于a##1b[->2:3]##1c这个序列，以下两个波形都是在180ns处匹配成功。

![非连续跟随重复符波形3](./image/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E8%B7%9F%E9%9A%8F%E9%87%8D%E5%A4%8D%E7%AC%A63.png "非连续跟随重复符波形3")

- a[=3]:非连续(无所谓跟随)重复操作符

含义是a无所谓连续不连续，反正重复3次那么就成功了。a[=1]等价于(!a)[*0:$]##1 a##1 (!a)[*0:$]，分析：(!a)的意思是a事件没有发生，(!a)[*0:$]意思是a任意多拍都没有发生($代表大于等于前面的那个值的任意数)，结合起来的意思就是a任意多拍都没有发生，终于在某一拍有效，有效之后，后面任意多拍都无效。

简单看一下a[=3]的波形理解

![非连续重复操作符1](./image/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%E7%AC%A61.png "非连续重复操作符1")

在图中标蓝的点都是匹配成功的点

- and运算符
  
and运算符用来连接两个事件(多为序列)，当两个事件均成功时匹配成功，需要注意的是两个事件必须有相同的起始点，但是可以有不同的结束点。举个简单的例子，(a##[2:4]b)and(a##5 c)在波形中可见，100ns处(a##[2:4]b)匹配成功，140ns处整个序列匹配成功，其他时间都是匹配失败的。

![and运算符](./image/and%E8%BF%90%E7%AE%97%E7%AC%A6.png "and运算符")

> 注：and和&在断言中的区别和联系。a&b也是要a和b同时成立的，不过此式中a和b必须为表达式，匹配也只能在每一拍内进行；而a and b中的a、b既可以是表达式又可以是序列，是可以进行跨拍匹配的。例如(sig_a == 5) & (sig_b == 3)也可以写成(sig_a == 5) and (sig_b == 3)，但是(a ##[2:4]b)and(a##5 c)不可以写作(a##[2:4]b)&(a##5 c)。

- or运算符
  
and运算符用来连接两个事件(多为序列)，当两个事件任一匹配成功则整体成功，与|的区别和之前类似，or可以连接两个表达式或是两个序列，|只能连接两个表达式。

- intersect运算符

intersect和and有一些类似，都是连接两个事件，两个事件均成功整个匹配才成功。不过intersect多了一个条件，那就是两个事件必须在同一时刻结束(and已经需要保证两个事件同一时刻开始)，换句话说a intersect b能匹配成功，a、b两个序列的长度必须相等。

- within运算符

a within b含义是在事件b(序列b)匹配期间，事件a(序列a)至少出现1次则匹配成功，否则匹配失败。

- throughout运算符

throughout运算符和intersect有些接近，不过区别在于throughout必须连接一个表达式和一个序列即reg throughout seq，含义是在seq匹配起始到结束期间，req都必须成立。

## 5、内建函数
- $rose

$rose()函数就是上升沿检测，匹配规则是信号的当拍值为1上拍数据为0。

- $fell

$fell()函数和$rose函数刚好相反，是下降沿检测。

- $change
  
$fell函数和$rose函数的结合体，当拍采样值与上一拍不一致则匹配成功。

- $stable
  
$stable和$change刚好相反，信号当拍采样值与上一拍一样则匹配成功。

- $onehot(a)：

任意时钟沿，表达式a都只有1bit为高；

- $onehot0(a)：

任意时钟沿，表达式a都只有1bit为高或这均为低电平；

- $isunkown(a)：

任意时钟沿，表达式a任意位是否有X态或者Z态，如果有则匹配，没有X态或Z态则报错；注意这个函数我们一般时~$isunkown(a)这样使用，在有X态或Z态时候我们希望报错出来；

- $countones(a)：

返回表达式中高电平的bit数量；

## 6、应用与实践

下面是实践中遇到的一些问题：

①编译后断言没有运行

在home目录下的.cshrc中配置仿真环境
```markdown
  setenv SIM_TOOL VCSM
```

②在testbench.sv中加入了interface来进行断言，但是将interface单独作为一个sv文件无法包含进去
解决方法1：
```
1、在testbench目录下新建一个文件夹interface
2、在这个文件夹下创建interface的sv文件
3、修改testbench目录下的vfiles文件，增加以下代码：
    +incdir+$SYS_TOP/testbench/interface
    $SYS_TOP/testbench/interface/clk_checker_if.sv
```

③在testbench.sv中添加interface并bind module后，可以在verdi中看到u_top层下面的interface并可以查看相关波形。如下图所示：

![verdi1](./image/verdi1.png "verdi1")

但是如果将interface的define从testbench.sv中移植到其他文件，则无法在verdi中找到interface并查看波形。

解决方法：修改sim文件夹下的verdi.f文件，增加以下指令：
```
  -f 工作目录/database/soc/hw/chips/everest2/asic/full_chip/testbench/vfiles
```